<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='动态规划方法以及典型问题介绍'><title>动态规划</title>

<link rel='canonical' href='https://horizonnn.github.io/p/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='动态规划'>
<meta property='og:description' content='动态规划方法以及典型问题介绍'>
<meta property='og:url' content='https://horizonnn.github.io/p/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/'>
<meta property='og:site_name' content='Bridge for us'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='算法' /><meta property='article:published_time' content='2021-03-31T13:23:26&#43;08:00'/><meta property='article:modified_time' content='2021-03-31T13:23:26&#43;08:00'/>
<meta name="twitter:title" content="动态规划">
<meta name="twitter:description" content="动态规划方法以及典型问题介绍">
    </head>
    <body class="">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.body.dataset.scheme = 'dark';
        } else {
            document.body.dataset.scheme = 'light';
        }
    })();
</script><div class="container main-container flex on-phone--column extended article-page with-toolbar">
            <aside class="sidebar left-sidebar sticky">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header class="site-info">
        
            <figure class="site-avatar">
                
                    
                    
                    
                        
                        <img src="/img/avatar2_hue4a4b3b0ebe0fe0bb9c038099fa80576_289792_300x0_resize_box_2.png" width="300"
                            height="299" class="site-logo" loading="lazy" alt="Avatar">
                    
                

                
            </figure>
        
        <h1 class="site-name"><a href="https://horizonnn.github.io/">Bridge for us</a></h1>
        <h2 class="site-description">Less is more. Slow is Fast.</h2>
    </header>

    <ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        

        <li >
            <a href='/about/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        

        
            <li id="dark-mode-toggle">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <span>Dark Mode</span>
            </li>
        
    </ol>
</aside>

            <main class="main full-width">
    <div id="article-toolbar">
        <a href="https://horizonnn.github.io/" class="back-home">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



            <span>Back</span>
        </a>
    </div>

    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E7%AE%97%E6%B3%95/" >
                算法
            </a>
        
            <a href="/categories/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" >
                背包问题
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
    </h2>

    
    <h3 class="article-subtitle">
        动态规划方法以及典型问题介绍
    </h3>
    <footer class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <time class="article-time--published">Mar 31, 2021</time>
    </footer></div>
</header>

    <section class="article-content">
    <h1 id="动态规划">动态规划</h1>
<h3 id="为什么需要动态规划">为什么需要动态规划</h3>
<p>分治法通常将问题划分为互不相交的子问题，递归地求解子问题，从而得到原问题的解。但在不同的子问题具有公共地子子问题的时候，分治法会做很多重复性的工作。所以这时候就需要用到动态规划，动态规划对每个子子问题只求解一次，然后保存在表格中，这样通过空间换时间来避免不必要的重复计算工作。</p>
<p>举个例子来说就是有如下这样一个钢条切割的问题</p>
<h5 id="钢条切割">钢条切割</h5>
<p><em>假定我们知道Serling公司出售一段长度为i英寸的钢条的价格为p；（i=1，2，…，单位为美元）。钢条的长度均为整英寸。如下给出了一个价格表的样例。</em></p>
<table>
<thead>
<tr>
<th>长度</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>价格</td>
<td>1</td>
<td>5</td>
<td>8</td>
</tr>
</tbody>
</table>
<p><em>则给定一段长度为n英寸的钢条和一个价格表，求切割钢条方案，使得销售收益r最大。</em></p>
<p>我们如果采用分治法的思想，那么一个长度为n的的钢条就会有接近$2^{n-1}$种切割方式，因为距离钢条左端i (i=1, 2, &hellip;, n-1)处，我们都可以选择切割或者不切割，但是这样指数上升的复杂度是随着问题规模增长而无法接受的。分治法的代码结构如下，当然下面的代码可以进一步优化，但是为了与动态规划进行对比说明，我们采用如下最直观的写法。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// restLength 代表从当前决策位置到最右端的钢条长度
</span><span class="c1">// rewardArr 代表不同的切割长度的价格数组
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">cut</span><span class="p">(</span><span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">priceArr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">priceArr</span><span class="p">[</span><span class="n">preNoCutLength</span><span class="p">];</span> <span class="c1">// 递归终止条件，当遍历到钢条最右端的时候返回
</span><span class="c1"></span>    <span class="c1">// 标识所有的递归结果中返回最大的
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">maxReward</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 循环递归调用，找到最大的返回值
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">priceArr</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">length</span><span class="o">-</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">reward</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">length</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">priceArr</span><span class="p">);</span>
            <span class="n">maxReward</span> <span class="o">=</span> <span class="n">maxReward</span> <span class="o">&gt;</span> <span class="n">reward</span> <span class="o">?</span> <span class="nl">maxReward</span> <span class="p">:</span> <span class="n">reward</span><span class="p">;</span>
        <span class="p">}</span> 
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">maxReward</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">priceArr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">ironLength</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">ironLength</span><span class="p">,</span> <span class="n">priceArr</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="自顶向下的动态规划">自顶向下的动态规划</h3>
<p>那么为了解决这个问题，就需要考虑分治法为什么没办法很好地解决这一问题。这是因为不同算法所适用的情况不同，分治法适合解决子问题之间不重叠的问题。而其本质原因就在于分治法如果用于重叠的子问题，则会产生很多重复计算过程。比如在上述钢条切割问题中。cut(4, 1)会递归调用cut(3, 1)和cut(3, 2)，这是分治的体现。而cut(3,1)则会递归调用cut(2, 1)和cut(2, 2); cut(3,2)也会递归调用cut(2, 1)和cut(2, 3)。可以看到cut(2, 1)在不同的分治路径里重复计算了两次，所以会导致时间效率低的问题。</p>
<p>那么针对这个问题，很多人可以直接想到，既然会出现重复计算，那么在递归调用的过程中保存一个数组来记录之前cut()函数的计算结果不就行了，这样在之后的递归调用过程中如果用到了就直接从数组中查找不就可以了。对的，这种带备忘录的分治法其实就是自顶向下的动态规划。而动态规划对比分治法其实就是一种空间换时间的办法。</p>
<h3 id="自底向上的动态规划">自底向上的动态规划</h3>
<p>而问题进行到这又会想到，采用分治法去递归地计算问题是因为不知道明确的计算路径，那么既然现在已经有个一个结果数组了，能够将计算结果保存下来，那为什么不采用自底向上地计算模式呢，通过循环来迭代的去计算最终结果。而这样的思路就是自底向上的动态规划。相关代码如下</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// restLength 代表从当前决策位置到最右端的钢条长度
</span><span class="c1">// preNoCutLength 代表从上一次切割位置到当前决策位置的长度
</span><span class="c1">// rewardArr 代表不同的切割长度的价格数组
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">cut</span><span class="p">(</span><span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">priceArr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// dp数组，作用和分治法中的备忘录一样，用来记录子问题结果
</span><span class="c1"></span>    <span class="c1">// 数组长度设为1一方面是保留一个rewardArr[0]作为起始点，类似递归中终止条件的作用
</span><span class="c1"></span>    <span class="c1">// 另一方面是索引值与数组意义严格对应，rewardArr[i]代表的就是长为i的钢条的最大收益
</span><span class="c1"></span>    <span class="c1">// 而不用编程的时候再考虑数组索引从0开始，加1减1之类的影响思路
</span><span class="c1"></span>    <span class="kt">int</span><span class="o">*</span> <span class="n">rewardArr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">rewardArr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
    <span class="c1">// 动态规划内层循环
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 内层实现dp计算公式：dp[i] = max(price[1] + reward[i-1], price[2] + reward[i-2], price[3] + reward[i-3])
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">priceArr</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">reward</span> <span class="o">=</span> <span class="n">priceArr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">rewardArr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)];</span>
                <span class="n">rewardArr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rewardArr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">reward</span> <span class="o">?</span> <span class="n">rewardArr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:</span> <span class="n">reward</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">rewardArr</span><span class="p">[</span><span class="n">length</span><span class="p">];</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">rewardArr</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">priceArr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">30</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">ironLength</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">ironLength</span><span class="p">,</span> <span class="n">priceArr</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>可以看到动态规划内部的计算方式其实和分治法是一样的，都是将动态转移方程直接代码化。只不过外层由递归调用变成了循环结构。</p>
<h3 id="自底向上与自顶向下的优劣">自底向上与自顶向下的优劣</h3>
<p>两者在数据上的空间复杂度是一致的。但是自顶向下的方式由于一般采用递归的形式去实现，所以函数栈会造成额外的开销。但自顶向下的方式也并不是没有优势，在某些特殊情况下，自顶向下的方式会避免一些不必要的计算过程。比如钢条问题中，如果钢条只能切割成长度为2或者长度为4的小钢条，那么对于长度为6的切割问题，自底向上的方式依然会循环计算从1到6的最大收益，因为自底向上的遍历方式没办法知道计算6的时候是不是需要1-5的全部信息，所以没办法选择性计算。而自顶向下的方式这时候就能体现出在计算上的效率，因为是从6开始递归调用，所以在计算过程中不会计算5，3，1的最大收益，在这一方面能够提高时间效率。</p>
<p>总的来说，自底向上的动态规划适用于递归密集型的问题，而自顶向下适合递归稀疏型的问题。比如dp[i] = 1+ dp[i-1]这种适合用自底向上的方式求解，而dp[i] = 1+ dp[i-10]这种适合自顶向下的方式求解。</p>
<h3 id="动态规划问题求解步骤">动态规划问题求解步骤</h3>
<ol>
<li>提炼主要问题</li>
<li>找到符合最优子结构的问题定义</li>
<li>递归地定义最优解的值</li>
<li>计算最优解的值，通常采用自底向上的方法</li>
<li>利用计算出的信息构造一个最优解</li>
</ol>
<p>针对Leetcode第494题目标和进行分析。</p>
<p><em>给定一个非负整数数组，a1, a2, &hellip;, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</em></p>
<pre><code>输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5
解释：
-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
</code></pre><p>一种方法就是简单递归让目标数S从第一位开始前往后递归加减，然后到最后一位判断是否等于0，因为不操作到最后一位无法明确知道是否能够大于S，所以不存在剪枝操作。【这个操作当作一个额外的方法来叙述也行，然后讲一下和前面这个的区别】</p>
<p>基本就是递归，而为了保存节约时间呢，需要将数据进行保存，而实际上这个递归的过程中count的变化量实际上就等于后面的递归中等于这个数的操作的数目，然后就改成了nums递归的形式，这样就有了返回值，然后这个形式再去改成循环就改成了我的代码的形式。然后就是我的代码其实在空间复杂度上需要进一步优化。</p>
<h5 id="提炼主要问题">提炼主要问题</h5>
<p>往往第一大难点就是对于问题的提炼，不要过分纠结于字面信息，而要寻找背后的考点和本质特征。要把题目给定的问题转化成熟悉的问题或者模板化的问题。</p>
<p>其实这道题可以转化成完全的01背包问题来进一步提高时间效率和空间效率。</p>
<p>01背包问题是选或者不选，但本题是必须选，是选+还是选-。先将本问题转换为01背包问题。
假设所有符号为+的元素和为x，符号为-的元素和的绝对值是y。
我们想要的 S = 正数和 - 负数和 = x - y
而已知x与y的和是数组总和：x + y = sum
可以求出 x = (S + sum) / 2 = target
也就是我们要从nums数组里选出几个数，令其和为target
于是就转化成了求容量为target的01背包问题 =&gt;要装满容量为target的背包</p>
<p>但为了体现一般思路，这道题采用如下的普通动态规划的做法。</p>
<h5 id="找到符合最优子结构的问题定义">找到符合最优子结构的问题定义</h5>
<p>最优子结构性质：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。</p>
<p>通常情况下，符合最优子结构的问题定义就是题目的直接问题。比如这个问题，问的就是最终数组和未目标数S的所有添加符号的方法数。所以就可以直接定义counts[nums, S]表示用数组nums组成S的的方法数。</p>
<h5 id="递归地定义最优解的值">递归地定义最优解的值</h5>
<p>这一步就是想办法把上一步定义的问题用递归的形式表示出来，其实就是写出来动态转移方程，最好写下来，这样在之后写代码的时候就无脑照葫芦画瓢就行了。</p>
<p>根据问题定义可知如果希望nums添加的的符号得到的和为S的话，那么去掉最后一位的数和符号，剩下的和一定为S - num[n-1]或者S + nums[n-1]。而两者又是互不相交的子问题，所以$counts(nums, S) = nums(nums[:n-1], S-nums[n-1]) + nums(nums[:n-1], S+nums[n-1])$。为了下面的程序表示方便，重新考虑一下counts的定义，定义counts[i, S]为利用前i个数得到目标数为S的方法数。则可以得到如下状态转移方程
$$
counts[i, S] = \begin{cases}
S == nums[0] || S == -nums[0] &amp; i = 0 \\ counts[ i-1, S-nums[i-1] ] + counts[ i-1, S+nums[i-1] ] &amp; i &gt; 0 \end{cases}
$$
动态转移方程一般初始条件需要着重注意。</p>
<h5 id="计算最优解的值通常采用自底向上的方法">计算最优解的值，通常采用自底向上的方法</h5>
<p>这个就不用多说了，编代码其实是动态规划问题最简单的一部分了，基本就是两个循环（外层迭代循环和内层dp数组动态赋值）+一个形式化的动态转移方程（针对复杂的计数和布尔问题可能也会以循环的形式来代码化）就能解决问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">findTargetSumWays</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">results</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">sum</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">resultsPre</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">sum</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">sum</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">resultsPre</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">sum</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>

        <span class="n">resultsPre</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">sum</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">resultsPre</span><span class="p">[</span><span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">sum</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

    	<span class="c1">// 外层循环，不断迭代
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 内层循环，dp数组顺序赋值
</span><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">sum</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// 动态转移方程的形式化表述
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">resultsPre</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">resultsPre</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">resultsPre</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="kt">int</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">results</span><span class="p">;</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">resultsPre</span><span class="p">;</span>
            <span class="n">resultsPre</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">sum</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">times</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">S</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">sum</span> <span class="o">||</span> <span class="n">S</span> <span class="o">&gt;</span> <span class="n">sum</span><span class="p">)</span>
            <span class="n">times</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">resultsPre</span><span class="p">[</span><span class="n">S</span><span class="o">+</span><span class="n">sum</span><span class="p">];</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">results</span><span class="p">;</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">resultsPre</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div><h5 id="利用计算出的信息构造一个最优解">利用计算出的信息构造一个最优解</h5>
<p>对于有些问题，可能动态规划定义的问题并不是原问题的解，所以可能还需要后续针对问题进行处理，这一步就相当于<strong>提炼主要问题</strong>的反向，把定义的问题再反向推导回原问题的解。</p>
<p>而这个题很简单，就是counts[n-1, S]，索引后直接返回就行。</p>
<h5 id="技巧">技巧</h5>
<p>其实这个问题如果从简单+和-的操作来看，可以看成是一个简单的分治问题，对于每一位都可能有+和-的操作，而且互不重叠。所以着本质上还是一个完全背包排列问题。所以可以很简单地写出利用递归实现分治法的代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// 核心递归函数
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">findTargetSumWaysCore</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rest</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 递归终止条件：nums遍历到头，如果结果等于0，那么计数加一
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rest</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 未终止则进行后续递归调用
</span><span class="c1"></span>    <span class="n">findTargetSumWaysCore</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">rest</span><span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="n">findTargetSumWaysCore</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">rest</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 入口函数，进行接口转换、合法性检查以及调用递归函数
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">findTargetSumWays</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">S</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">findTargetSumWaysCore</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>一般采用这种自顶向下的递归方式来分析问题，然后采用自底向上的动态规划来解决问题。如果不会写动态转移方程，觉得子问题很难分析的话。可以按照分治法 &ndash;&gt; 带备忘录的自顶向下动态规划 &ndash;&gt; 自底向上的动态规划的路线来渐进得到解决办法。</p>
<p>比如这个问题，上述分治法想变成带备忘录的自顶向下的模型的话，就需要存储每次递归调用的结果。针对这个问题，虽然函数没有返回值，但递归调用的结果就是count数的变化，而这个值实际上就是剩余的数组值操作能得到的rest-nums[index]和rest+nums[index]数的加和，这样这个动态规划数组的定义就出来了，和前面的问题一样，剩下的就是考虑怎么把自顶向下的递归转化成自底向上的循环了。</p>
<h3 id="适合动态规划的相关问题">适合动态规划的相关问题</h3>
<h5 id="按照问题结果分类">按照问题结果分类</h5>
<ul>
<li>加和类</li>
<li>布尔操作类</li>
<li>最大最小值类</li>
</ul>
<h5 id="按照问题类型分类">按照问题类型分类</h5>
<p>总的来说就是有顺序关联的问题，通过迭代计算能够减少重复计算数目。</p>
<ul>
<li>数学问题：斐波那契数列、矩阵链乘法</li>
<li>背包问题</li>
<li>矩阵问题</li>
<li>子序列问题</li>
<li>字符串操作</li>
<li>股票交易</li>
</ul>
<h1 id="背包问题">背包问题</h1>
<p>![背包问题](pictures/package problem.png)</p>
<h3 id="01背包问题">01背包问题</h3>
<h5 id="基本公式">基本公式</h5>
<p>一般01背包问题的公式都是</p>
<ul>
<li>计数问题：$dp[i, j] = dp[i-1, j] + dp[i-1, j-weight[i]]$</li>
<li>最大最小问题：$dp[i, j] = \max (dp[i-1, j], dp[i-1, j-weight[i]]+value[i])$</li>
<li>布尔问题：$dp[i, j] = dp[i-1, j] \ || \ dp[i-1, j-nums[i]]$</li>
</ul>
<p>即只考虑前第i个元素等于j的结果等于只考虑前i-1个元素等于j的结果加上只考虑前i-1个元素等于j-nums[i]的结果。其中function根据问题不同采用不同的形式，如果是计数类就是sum函数，如果是布尔类就是与或函数，如果是最大最小类就是max/min函数。详细区分一下不同function的公式结果</p>
<h5 id="416-分割等和子集">416. 分割等和子集</h5>
<p><em>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</em></p>
<pre><code>输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].
</code></pre><ul>
<li>首先可以认识到【分割成两个子集相等】其实就等同于【能找到一个子集的和是整个集合和的一半】。然后问题就变成了给定一个数（集合总和的一半），寻找集合中是否有加和等于这个数的子集，然后进一步退化，这就是一个简单的0-1背包问题了。</li>
</ul>
<h5 id="494-目标和">494. 目标和</h5>
<p><em>给定一个非负整数数组，a1, a2, &hellip;, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</em></p>
<pre><code>输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5
解释：
-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
</code></pre><ul>
<li>解法一：假设数组中所有前面为加号的数的和为x，所有前面为减号的数的和为y，所有数的加和为sum（可被计算出来）。那么就有x-y = S， x+y = sum，从而可以得到x = (S+sum)/2，那其实问题就转换成了再数组中找加和等于(S+sum)/2的子集个数，就又成了一个01背包问题。</li>
<li>解法二：这个问题也可以看成是一个特殊的01背包问题。虽然为选1的时候问题不变还是dp[i-1, j-nums[i]]。但是选0的时候问题变了，即0的时候也不是没有价值的了，价值变成了-nums[i]，所以动态转移方程就成了$dp[i, j] = \text{function} \ ( dp[i-1, j+nums[i]], dp[i-1, j-nums[i]])$，变成一个略特殊的01背包问题。</li>
</ul>
<h5 id="474-一和零">474 一和零</h5>
<p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="err">输入：</span><span class="n">strs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#34;10&#34;</span><span class="p">,</span> <span class="s">&#34;0001&#34;</span><span class="p">,</span> <span class="s">&#34;111001&#34;</span><span class="p">,</span> <span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;0&#34;</span><span class="p">],</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="err">输出：</span><span class="mi">4</span>
<span class="err">解释：最多有</span> <span class="mi">5</span> <span class="err">个</span> <span class="mi">0</span> <span class="err">和</span> <span class="mi">3</span> <span class="err">个</span> <span class="mi">1</span> <span class="err">的最大子集是</span> <span class="p">{</span><span class="s">&#34;10&#34;</span><span class="p">,</span><span class="s">&#34;0001&#34;</span><span class="p">,</span><span class="s">&#34;1&#34;</span><span class="p">,</span><span class="s">&#34;0&#34;</span><span class="p">}</span> <span class="err">，因此答案是</span> <span class="mi">4</span> <span class="err">。</span>
<span class="err">其他满足题意但较小的子集包括</span> <span class="p">{</span><span class="s">&#34;0001&#34;</span><span class="p">,</span><span class="s">&#34;1&#34;</span><span class="p">}</span> <span class="err">和</span> <span class="p">{</span><span class="s">&#34;10&#34;</span><span class="p">,</span><span class="s">&#34;1&#34;</span><span class="p">,</span><span class="s">&#34;0&#34;</span><span class="p">}</span> <span class="err">。</span><span class="p">{</span><span class="s">&#34;111001&#34;</span><span class="p">}</span> <span class="err">不满足题意，因为它含</span> <span class="mi">4</span> <span class="err">个</span> <span class="mi">1</span> <span class="err">，大于</span> <span class="n">n</span> <span class="err">的值</span> <span class="mi">3</span> <span class="err">。</span>
</code></pre></div><ul>
<li>也是一个变形的01背包问题。只不过这里面背包容量变成了m和n的共同限制，物品重量分别是0和1的数量，物品价值就是1（因为整体价值就是子集包含的元素个数）。</li>
</ul>
<h5 id="优化技巧">优化技巧</h5>
<ul>
<li>空间优化：一般的01背包问题需要定义一个二位矩阵存储中间结果，但是如果采用倒序遍历的做法，就可以只定义一个一维数组来降低空间复杂度。</li>
</ul>
<h3 id="完全背包问题">完全背包问题</h3>
<h5 id="基本公式-1">基本公式</h5>
<p>一般完全背包问题的公式都是</p>
<ul>
<li>计数问题：$dp[i, j] = dp[i-1, j] + dp[i, j-weight[i]]$</li>
<li>最大最小问题：$dp[i, j] = \max (dp[i-1, j], dp[i, j-weight[i]]+value[i])$</li>
<li>布尔问题：$dp[i, j] = dp[i-1, j] \ || \ dp[i, j-weight[i]]$</li>
</ul>
<p>和01背包问题的区别仅仅是在于后一项的索引是i-1还是i。体现在代码上，对比经过空间优化的01背包问题，仅仅是内层循环是正序还是倒序的问题。</p>
<h5 id="322-零钱兑换">322 零钱兑换</h5>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。你可以认为每种硬币的数量是无限的。</p>
<pre><code>输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
</code></pre><ul>
<li>就是一个简单的完全背包的最大最小问题，直接套模板就行。</li>
</ul>
<h5 id="518-零钱兑换2">518 零钱兑换2</h5>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p>
<pre><code>输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
</code></pre><ul>
<li>就是一个简单的完全背包的计数问题，直接套模板就行</li>
</ul>
<h5 id="139-单词拆分">139 单词拆分</h5>
<p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。</p>
<pre><code>输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]
输出: true
解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。
</code></pre><ul>
<li>还是一个完全背包的布尔问题。只不过判断条件相比普通的背包问题有所变化，需要稍稍修正。</li>
</ul>
<h5 id="279-完全平方数">279 完全平方数</h5>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, &hellip;）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<pre><code>输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
</code></pre><ul>
<li>这也是个最大最小的完全背包问题，只不过能使用的完全平方数（物品）需要提前自己计算出来，然后就是动态规划数组初值和边界条件这些细节问题了。</li>
</ul>
<h3 id="完全背包排列问题">完全背包排列问题</h3>
<h5 id="基本公式-2">基本公式</h5>
<p>一般完全背包排列问题的公式都是</p>
<ul>
<li>计数问题：$dp[j] = dp[j-weight[1]] + dp[i, j-weight[2]] + &hellip; + dp[i, j-weight[n]]$</li>
<li>最大最小问题：$dp[i, j] = \max (dp[j-weight[1]] , dp[i, j-weight[2]] , &hellip; , dp[i, j-weight[n]])$</li>
<li>布尔问题：$dp[i, j] = dp[j-weight[1]] \ || dp[i, j-weight[2]] \ || &hellip; \ || dp[i, j-weight[n]]$</li>
</ul>
<p>完全背包排列问题看起来就是完全背包问题，只不过算的是排列数。看起来更难了，但其实很简单，由于是排列，所以不用考虑去重的问题，所以外层迭代根本不需要了，只需要顺序计算内层迭代就行了。</p>
<h5 id="70-爬楼梯">70 爬楼梯</h5>
<p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>**注意：**给定 <em>n</em> 是一个正整数。</p>
<pre><code>输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
</code></pre><ul>
<li>其实就可以看做是一个可选物品为重量{1，2}，背包容量为n的完全背包计数问题。</li>
</ul>
<h5 id="377-组合总和4">377 组合总和4</h5>
<p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<pre><code>输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
</code></pre><ul>
<li>就是个单纯的完全背包的排列问题。</li>
</ul>
<h1 id="矩阵问题">矩阵问题</h1>
<h5 id="62-不同路径">62 不同路径</h5>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<pre><code>输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右
3. 向下 -&gt; 向右 -&gt; 向下
</code></pre><ul>
<li>因为路径只能向下或者向右，所以令f(i,j)代表能到达(i, j)位置的路径数，则动态转移方程为$f(i, j) = f(i-1, j) + f(i, j-1)$</li>
</ul>
<h5 id="64-最小路径和">64 最小路径和</h5>
<p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>**说明：**每次只能向下或者向右移动一步。</p>
<pre><code>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
</code></pre><ul>
<li>同样是矩阵路径问题，只不过把计数换成了最大最小，从动态规划的形式上来说没什么区别。</li>
</ul>
<h1 id="数学问题">数学问题</h1>
<h5 id="矩阵链乘法问题">矩阵链乘法问题</h5>
<p>矩阵链乘法问题（matrix-chain multiplication problem）可描述如下：给定n个矩阵的链$&lt;A_1, A_2, &hellip;, A_n&gt;$，矩阵A的规模为$p_{i-1} \times p_i(1 \leq i \leq n) $，求完全括号化方案，使得计算乘积$A_1A_2&hellip;A_n$，所需标量乘法次数最少。</p>
<ul>
<li>其动态转移方程如下：
$$
m[i, j] = \begin{cases}
0 &amp; 如果i = j \\ \min_{i \leq k &lt; j} {m[i, k] + m[k+1, j] + p_{i-1}p_kp_j} &amp; 如果i &lt; j \end{cases}
$$</li>
</ul>
<h1 id="子序列问题">子序列问题</h1>
<h3 id="最长递增子序列">最长递增子序列</h3>
<p><a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/solution/chuan-shang-yi-fu-wo-jiu-bu-ren-shi-ni-liao-lai--2/">https://leetcode-cn.com/problems/maximum-length-of-pair-chain/solution/chuan-shang-yi-fu-wo-jiu-bu-ren-shi-ni-liao-lai--2/</a></p>
<h5 id="300-最长递增子序列">300 最长递增子序列</h5>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<pre><code>输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
</code></pre><ul>
<li>用一个数组存储长度为n的子序列的最小末尾。然后循环遍历nums[i]，如果nums[i]大于当前最大长度子序列的末尾，那就把它设为长度+1的子序列末尾。不然的话就二分查找存储在数组中的合适位置去更新。</li>
</ul>
<h5 id="646-最长数对链">646 最长数对链</h5>
<p>给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。</p>
<p>现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。</p>
<p>给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p>
<pre><code>输入：[[1,2], [2,3], [3,4]]
输出：2
解释：最长的数对链是 [1,2] -&gt; [3,4]
</code></pre><ul>
<li>依然是一个最长递增子序列问题，只不过需要我们提前对数组按第二个元素大小排好序。</li>
</ul>
<h3 id="摆动子序列">摆动子序列</h3>
<h5 id="376-摆动序列">376 摆动序列</h5>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<pre><code>输入: [1,7,4,9,2,5]
输出: 6 
解释: 整个序列均为摆动序列。
</code></pre><h3 id="公共子序列">公共子序列</h3>
<h5 id="1143-最长公共子序列">1143 最长公共子序列</h5>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，&ldquo;ace&rdquo; 是 &ldquo;abcde&rdquo; 的子序列，但 &ldquo;aec&rdquo; 不是 &ldquo;abcde&rdquo; 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<pre><code>输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 
输出：3  
解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。
</code></pre><ul>
<li>根据text1[i]与text2[j]是否相等分两种情况讨论，然后二维顺序递归就行。</li>
</ul>
<h5 id="583-两个字符串的删除操作">583 两个字符串的删除操作</h5>
<p>给定两个单词 <em>word1</em> 和 <em>word2</em>，找到使得 <em>word1</em> 和 <em>word2</em> 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<pre><code>输入: &quot;sea&quot;, &quot;eat&quot;
输出: 2
解释: 第一步将&quot;sea&quot;变为&quot;ea&quot;，第二步将&quot;eat&quot;变为&quot;ea&quot;
</code></pre><ul>
<li>其实跟<strong>1143 最长公共子序列</strong>是一样的，只不过找到公共子序列长度之后，需要再用两个字符串长度减一下。</li>
</ul>
<h1 id="字符串操作">字符串操作</h1>
<h5 id="650-只有两个键的键盘">650 只有两个键的键盘</h5>
<p>最初在一个记事本上只有一个字符 &lsquo;A&rsquo;。你每次可以对这个记事本进行两种操作：</p>
<p>Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
Paste (粘贴) : 你可以粘贴你上一次复制的字符。
给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 &lsquo;A&rsquo;。输出能够打印出 n 个 &lsquo;A&rsquo; 的最少操作次数。</p>
<pre><code>输入: 3
输出: 3
解释:
最初, 我们只有一个字符 'A'。
第 1 步, 我们使用 Copy All 操作。
第 2 步, 我们使用 Paste 操作来获得 'AA'。
第 3 步, 我们使用 Paste 操作来获得 'AAA'。
</code></pre><ul>
<li>其实就是找每个数的最大因子，如果n的最大因子是m。则f(n) = f(m) + n/m。</li>
</ul>
<h5 id="72-编辑距离">72 编辑距离</h5>
<p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<pre><code>输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
输出：3
解释：
horse -&gt; rorse (将 'h' 替换为 'r')
rorse -&gt; rose (删除 'r')
rose -&gt; ros (删除 'e')
</code></pre><ul>
<li>本质上还是怎么定义dp数组的含义。可以定义dp[i][j]为前一个单词的前i位和后一个单词的前j位匹配所需要的步数。如果word1[i]和word2[j]不同的话，那么针对word1就有插入、删除、替换三种操作；如果相同的话，又是另一种情况。所以可以根据这样来写动态转移方程。</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/zui-jian-dan-2-ge-bian-liang-jie-jue-suo-sgnm/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/zui-jian-dan-2-ge-bian-liang-jie-jue-suo-sgnm/</a></p>
<h1 id="股票交易">股票交易</h1>
<p>这种不同状态之间有转移限制相互冲突的问题就应该分成多个数组来分别计算讨论。</p>
<h5 id="121-买卖股票的最佳时机">121 买卖股票的最佳时机</h5>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<pre><code>输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
</code></pre><ul>
<li>其实就是找数组中前后相差最大的两个数，最好的做法就是设两个标志位，一个是当前最大差值，一个是当前的最小值。
用动态规划也能做就是时间复杂度高一些，用f(k)标记k节点卖出时的最大利润，然后迭代一遍就行了。</li>
</ul>
<h5 id="309-最佳买卖股票时机含冷冻期">309 最佳买卖股票时机含冷冻期</h5>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>
<pre><code>输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
</code></pre><ul>
<li>解法一：把某一天的状态分成持有股票、不持有股票但是在冷却期，不持有股票也不在冷却期三种情况。然后写出动态转移方程进行求解。</li>
<li>解法二：把某一天的状态分成买入和卖出两种状态，两种状态相互转移依赖。然后将冷却期的条件包含在买入的动态转移方程中。</li>
</ul>
<h5 id="714-买卖股票的最佳时机含手续费">714 买卖股票的最佳时机含手续费</h5>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<pre><code>输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
</code></pre><ul>
<li>同样还是把情况分成持有股票和不持有股票两种情况，然后就是卖股票的时候需要多减去一个手续费</li>
</ul>
<h5 id="123-买卖股票的最佳时机3">123 买卖股票的最佳时机3</h5>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<pre><code>输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
</code></pre><ul>
<li>这个情况就比较多了，分成第一次买入，第一次买入和卖出，第二次买入，第二次买入和卖出。。。然后循环迭代。</li>
</ul>
<h5 id="188-买卖股票的最佳时机">188 买卖股票的最佳时机</h5>
<p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<pre><code>输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
</code></pre><ul>
<li>就是123题的一般化形式。</li>
</ul>
<h1 id="其他">其他</h1>
<h5 id="413-等差数列划分">413 等差数列划分</h5>
<p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。</p>
<p>如果满足以下条件，则称子数组(P, Q)为等差数组：</p>
<p>元素 A[P], A[p + 1], &hellip;, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。</p>
<p>函数要返回数组 A 中所有为等差数组的子数组个数。</p>
<pre><code>A = [1, 2, 3, 4]

返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。
</code></pre><ul>
<li>设f(i)是以第i个元素结尾的等差数列的个数，那么当nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]时存在动态转移方程$f(k) = f(k-1) + 1$</li>
</ul>
<h5 id="196-打家劫舍">196 打家劫舍</h5>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<pre><code>输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
</code></pre><ul>
<li>这题还是考察堆动态转移方程的理解。通过题意，可以假设f(k)为最多打劫1-k房间的最高金额，则$f(k) = max( f(k-1), values[k]+f(k-2) )$</li>
</ul>
<h5 id="213-打家劫舍2">213 打家劫舍2</h5>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p>
<pre><code>输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
</code></pre><ul>
<li>跟<strong>196 打家劫舍</strong>没什么区别，只不过是要分情况讨论，因为首尾元素不能都取，所以就分成偷第一家和不偷第一家两种情况，剩下的动态规划过程就是一样的了。</li>
</ul>
<h5 id="91-解码方法">91 解码方法</h5>
<p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong></p>
<pre><code>'A' -&gt; 1
'B' -&gt; 2
...
'Z' -&gt; 26
</code></pre><p>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&ldquo;111&rdquo; 可以将 &ldquo;1&rdquo; 中的每个 &ldquo;1&rdquo; 映射为 &ldquo;A&rdquo; ，从而得到 &ldquo;AAA&rdquo; ，或者可以将 &ldquo;11&rdquo; 和 &ldquo;1&rdquo;（分别为 &ldquo;K&rdquo; 和 &ldquo;A&rdquo; ）映射为 &ldquo;KA&rdquo; 。注意，&ldquo;06&rdquo; 不能映射为 &ldquo;F&rdquo; ，因为 &ldquo;6&rdquo; 和 &ldquo;06&rdquo; 不同。</p>
<p>给你一个只含数字的 非空 字符串 num ，请计算并返回 解码 方法的 总数 。</p>
<p>题目数据保证答案肯定是一个 32 位 的整数。</p>
<ul>
<li>就是个带条件的一维动态规划，主要是写对判断条件，尤其是“0”怎么处理这种问题。</li>
</ul>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>

    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E6%96%B9%E6%B3%95/">
        
        

        <div class="article-details">
            <h2 class="article-title">基本特征选择方法</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/">
        
        

        <div class="article-details">
            <h2 class="article-title">线性回归评估指标</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>


    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (DISQUS) {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2021 Bridge for us
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="2.3.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >
            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
